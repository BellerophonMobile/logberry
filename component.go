package logberry

import (
	"os"
	"os/user"
	"path"
	"path/filepath"
	"strings"
)

// Component is a Context encapsulating an object, class, or cluster
// of functions and related functionality.  The precise meaning is
// largely left up to the calling code.  While a Task is a short lived
// particular activity, a Component is comparatively long lived and
// may do many different things throughout its life time.
//
// In general the Component's functions are safe to call concurrently.
type Component struct {
	uid    uint64
	parent Context
	root   *Root
	label  string

	class ComponentClass

	mute bool
	highlight bool
}


func newcomponent(parent Context, label string, data ...interface{}) *Component {

	var class = COMPONENT
	if data != nil && len(data) > 0 {
		if cc, ok := data[0].(ComponentClass); ok {
			class = cc
			data = data[1:]
		}
	}
	d := DAggregate(data)

	c := &Component{
		uid:    newcontextuid(),
		parent: parent,
		label:  label,
		class:  class,
	}

	if parent != nil {
		c.root = parent.GetRoot()
		d.Set(c.root.FieldPrefix+"Parent", parent.GetUID())
	} else {
		c.root = Std
	}

	if c.class < 0 || c.class >= componentclass_sentinel {
		c.root.InternalError(NewError("ComponentClass out of range", c.uid, c.class))
		d.Set(c.root.FieldPrefix+"Class", c.class)
	} else {
		d.Set(c.root.FieldPrefix+"Class", ComponentClassText[c.class])
	}

	if parent != nil {
		c.root.ComponentEvent(c, COMPONENT_START, "Instantiate", d)
	}

	return c

}


// Component creates a new component context as a child of this
// component.  Parameter label should be a usable short identifier for
// the new component, but its specific format and meaning is left up
// to the caller.  If the first field of the data is of type
// ComponentClass, the class of the new component will be set as such;
// the default is COMPONENT.  An instantiation log event will be
// generated by this call, including any data given.
//
// This is safe to call concurrently.
func (x *Component) Component(label string, data ...interface{}) *Component {
	return newcomponent(x, label, data...)
}

// Task creates a new task context as a child of this component.
// Parameter activity should be a short natural language description
// of the work carried out by this activity, without any terminating
// punctuation.  Any data given will be associated with the task and
// reported with its events.  This call does not produce a log event.
// Use Begin() to indicate the start of a long running task.
//
// This is safe to call concurrently.
func (x *Component) Task(activity string, data ...interface{}) *Task {
	return newtask(x, activity, data)
}


// Getlabel return the label of this Component, as given at
// instantiation.
func (x *Component) GetLabel() string {
	return x.label
}

// GetUID returns the unique identifier for this Component.
func (x *Component) GetUID() uint64 {
	return x.uid
}

// GetParent returns the Context containing this Component.
func (x *Component) GetParent() Context {
	return x.parent
}

// GetRoot returns the Root for this Component.
func (x *Component) GetRoot() *Root {
	return x.root
}

// GetClass returns the ComponentClass for this Component.
func (x *Component) GetClass() ComponentClass {
	return x.class
}


// Mute indicates that this Component should not generate log events.
// This is useful when using the Component merely to organize
// subcomponents and tasks.  Specific OutputDrivers may ignore this.
func (x *Component) Mute() *Component {
	x.mute = true
	return x
}

// Unmute indicates that this Component should no longer be muted.
func (x *Component) Unmute() *Component {
	x.mute = false
	return x
}

// IsMute returns true iff the Component is muted.
func (x *Component) IsMute() bool {
	return x.mute
}


// Highlight indicates that the Component should be distinguished in
// some way in the output.  The specific behavior implementing this is
// determined by the OutputDrivers, which may ignore the flag.
func (x *Component) Highlight() *Component {
	x.highlight = true
	return x
}

// ClearHighlight indicates that the Component should no longer be
// distinguished in the log output.
func (x *Component) ClearHighlight() *Component {
	x.highlight = false
	return x
}

// IsHighlighted returns true iff the Component is highlighted.
func (x *Component) IsHighlighted() bool {
	return x.highlight
}

// Build generates a configuration log event reporting the source code
// and build platform configuration for this Component.
func (x *Component) Build(build *BuildMetadata) {
	x.root.ComponentEvent(x, COMPONENT_CONFIGURATION, "Build", DBuild(build))
}

// Configuration generates a configuration log event reporting the
// parameters and initialization data for this Component.
func (x *Component) Configuration(data ...interface{}) {
	x.root.ComponentEvent(x, COMPONENT_CONFIGURATION, "Configuration",
		DAggregate(data))
}

// CommandLine generates a configuration log event reporting the
// command line used to execute the currently executing process.
func (x *Component) CommandLine() {

	hostname, err := os.Hostname()
	if err != nil {
		x.root.InternalError(WrapError(err, "Could not retrieve hostname"))
		return
	}

	u, err := user.Current()
	if err != nil {
		x.root.InternalError(WrapError(err, "Could not retrieve user info"))
		return
	}

	dir, err := filepath.Abs(filepath.Dir(os.Args[0]))
	if err != nil {
		x.root.InternalError(WrapError(err, "Could not retrieve program path"))
		return
	}

	prog := path.Base(os.Args[0])

	d := D{
		"Host":    hostname,
		"User":    u.Username,
		"Path":    dir,
		"Program": prog,
		"Args":    os.Args[1:],
	}

	x.root.ComponentEvent(x, COMPONENT_CONFIGURATION, "Command line", &d)

}

// Environment generates a configuration log event reporting the
// current operating system host environment variables of the
// currently executing process.
func (x *Component) Environment() {

	d := D{}
	for _, e := range os.Environ() {
		pair := strings.Split(e, "=")
		d[pair[0]] = pair[1]
	}
	x.root.ComponentEvent(x, COMPONENT_CONFIGURATION, "Environment", &d)

}

// Process generates a configuration log event reporting identifiers
// for the currently executing process.
func (x *Component) Process() {

	hostname, err := os.Hostname()
	if err != nil {
		x.root.InternalError(WrapError(err, "Could not retrieve hostname"))
		return
	}

	wd, err := os.Getwd()
	if err != nil {
		x.root.InternalError(WrapError(err, "Could not retrieve working dir"))
		return
	}

	u, err := user.Current()
	if err != nil {
		x.root.InternalError(WrapError(err, "Could not retrieve user info"))
		return
	}

	d := D{
		"Host": hostname,
		"WD":   wd,
		"UID":  u.Uid,
		"User": u.Username,
		"PID":  os.Getpid(),
	}

	x.root.ComponentEvent(x, COMPONENT_CONFIGURATION, "Process", &d)

}


// Info generates an informational log event reporting the given
// message and data.
func (x *Component) Info(msg string, data ...interface{}) {
	x.root.ComponentEvent(x, COMPONENT_INFO, msg, DAggregate(data))
}

// Recovered generates a warning log event noting that the given error
// was encountered but execution has continued acceptably.
func (x *Component) Recovered(msg string, err error, data ...interface{}) {
	x.root.ComponentEvent(x, COMPONENT_WARNING, msg,
		DAggregate(data).Set(x.root.FieldPrefix+"Error", err.Error()))
}

// Warning generates a warning log event reporting the given condition
// and data.
func (x *Component) Warning(msg string, data ...interface{}) {
	x.root.ComponentEvent(x, COMPONENT_WARNING, msg, DAggregate(data))
}

// Error generates an error log event reporting a fault.  An error
// wrapping the original error with the given message is returned.
func (x *Component) Error(msg string, err error, data ...interface{}) error {

	// Note that this can't/shouldn't just throw err into the data blob
	// because the standard errors package error doesn't expose
	// anything, even the message.  So you basically have to reduce to a
	// string via Error().

	x.root.ComponentEvent(x, COMPONENT_ERROR, msg,
		DAggregate(data).Set(x.root.FieldPrefix+"Error", err.Error()))
	return WrapError(err, msg)

}

// Failure generates an error log event reporting a fault without an
// originating error.  It returns an error wrapping the given message.
//
// Failure and Error are essentially the same, the difference being
// that Failure is useful to both report and generate a fault detected
// directly by the calling code, rather than one caused by an
// underlying error returned from another function or component.
func (x *Component) Failure(msg string, data ...interface{}) error {
	x.root.ComponentEvent(x, COMPONENT_ERROR, msg, DAggregate(data))
	return NewError(msg)
}

// Fatal generetas a fatal log event reporting the given error and
// then terminates the currently executing process.  In general only
// top level code should invoke this.
func (x *Component) Fatal(msg string, err error, data ...interface{}) {
	x.root.ComponentEvent(x, COMPONENT_FATAL, msg,
		DAggregate(data).Set(x.root.FieldPrefix+"Error", err.Error()))
	os.Exit(1)
}

// Abort generetas a fatal log event reporting the given message and
// then terminates the currently executing process.  In general only
// top level code should invoke this.
//
// Abort and Fatal are essentially the same, the difference being that
// Abort is useful to both report and terminate on a fault detected
// directly by the calling code, rather than one caused by an
// underlying error returned from another function or component.
func (x *Component) Abort(msg string, data ...interface{}) {
	x.root.ComponentEvent(x, COMPONENT_FATAL, msg, DAggregate(data))
	os.Exit(1)
}


// Finalize generates a finished log event noting that the component
// has terminated, been cleaned up, or is otherwise about to cease
// being operational.  It is not called automatically in any way.
func (x *Component) Finalize(data ...interface{}) {
	x.root.ComponentEvent(x, COMPONENT_FINISH, "Finalize", DAggregate(data))
}

// Ready generates a ready log event noting that the component is
// fully instantiated, configured, and ready to operate.  This is
// useful, e.g., for test code to easily, semantically monitor a
// process' output for such a message indicating that it has booted
// and is ready to be sent data.
func (x *Component) Ready(msg string, data ...interface{}) {
	x.root.ComponentEvent(x, COMPONENT_READY, msg, DAggregate(data))
}
