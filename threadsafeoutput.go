package logberry

// ThreadSafeOutput ensures that log events are pushed to a client
// OutputDriver in sequential order.  It uses a simple buffered
// channel and goroutine to place log events in order as received and
// output as able.
//
// Note that detaching a ThreadSafeOutput is not threadsafe: Any
// buffered events will continue processing against the null root and
// cause an exception.  Because this usage should be very rare, no
// check or other mechanism is employed to prevent this.
type ThreadSafeOutput struct {
	root    *Root
	driver  OutputDriver
	channel chan logevent
}

type logevent interface {
	log(driver OutputDriver)
}

type componentevent struct {
	component *Component
	class     ComponentEventClass
	msg       string
	data      *D
}

func (x *componentevent) log(driver OutputDriver) {
	driver.ComponentEvent(x.component, x.class, x.msg, x.data)
}

type taskevent struct {
	task  *Task
	event TaskEventClass
}

func (x *taskevent) log(driver OutputDriver) {
	driver.TaskEvent(x.task, x.event)
}

type taskprogress struct {
	task  *Task
	event TaskEventClass
	msg   string
	data  *D
}

func (x *taskprogress) log(driver OutputDriver) {
	driver.TaskProgress(x.task, x.event, x.msg, x.data)
}

func (x *ThreadSafeOutput) process() {

	for {
		e := <-x.channel
		e.log(x.driver)
	}

}

// NewThreadSafeOutput creates a ThreadSafeOutput attached to the
// given client OutputDriver, with the specified channel buffer size.
func NewThreadSafeOutput(driver OutputDriver, buffer int) *ThreadSafeOutput {

	ts := &ThreadSafeOutput{
		driver:  driver,
		channel: make(chan logevent, buffer),
	}

	go ts.process()

	return ts
}

// Attach notifies the OutputDriver of its Root.  It should only be
// called by a Root.
func (x *ThreadSafeOutput) Attach(root *Root) {
	x.root = root
	x.driver.Attach(root)
}

// Detach notifies the OutputDriver that it has been removed from its
// Root.  It should only be called by a root.
func (x *ThreadSafeOutput) Detach() {
	x.driver.Detach()
	x.root = nil
}

// ComponentEvent logs an event generated by a Component.  It should
// only be called by a Root or an OutputDriver chaining outputs.
func (x *ThreadSafeOutput) ComponentEvent(component *Component,
	class ComponentEventClass,
	msg string,
	data *D) {

	x.channel <- &componentevent{
		component: component,
		class:     class,
		msg:       msg,
		data:      data,
	}

}

// TaskEvent logs an event generated by a Task.  It should only be
// called by a Root or an OutputDriver chaining outputs.
func (x *ThreadSafeOutput) TaskEvent(task *Task,
	event TaskEventClass) {

	x.channel <- &taskevent{
		task:  task,
		event: event,
	}

}

// TaskProgress logs an event generated by a Task.  It should only be
// called by a Root or an OutputDriver chaining outputs.
func (x *ThreadSafeOutput) TaskProgress(task *Task,
	event TaskEventClass,
	msg string,
	data *D) {

	x.channel <- &taskprogress{
		task:  task,
		event: event,
		msg:   msg,
		data:  data,
	}

}
