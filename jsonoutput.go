package logberry

import (
	"encoding/json"
	"fmt"
	"io"
	"time"
)

// JSONOutput is an OutputDriver that writes log events in JSON.  It
// has the following public properties:
//
//   DifferentialTime           Set to true to timestamp logs based on
//                              the duration since the start of the
//                              run rather than the absolute time.
type JSONOutput struct {
	root   *Root
	writer io.Writer

	start            time.Time
	DifferentialTime bool
}

// NewJSONOutput creates a new JSONOutput targeted at the given
// Writer.  DifferentialTime defaults to false.
func NewJSONOutput(w io.Writer) *JSONOutput {
	return &JSONOutput{
		writer:           w,
		start:            time.Now(),
		DifferentialTime: false,
	}
}

// Attach notifies the OutputDriver of its Root.  It should only be
// called by a Root.
func (x *JSONOutput) Attach(root *Root) {
	x.root = root
}

// Detach notifies the OutputDriver that it has been removed from its
// Root.  It should only be called by a root.
func (x *JSONOutput) Detach() {
	x.root = nil
}

func (x *JSONOutput) timestamp() string {

	if x.DifferentialTime {
		return time.Since(x.start).String()
	}

	return time.Now().Format(time.RFC3339)

	// end timestamp
}

func (x *JSONOutput) internalerror(err error) {

	fmt.Fprintf(x.writer, "{\"EntryType\":\"error\",\"Error\": %q}\n",
		err.Error())

	x.root.InternalError(WrapError(err, "Could not output log entry"))

}

func (x *JSONOutput) contextevent(entrytype string,
	context Context,
	event string,
	msg string,
	data *D) {

	var entry = make(map[string]interface{})
	entry["EntryType"] = entrytype
	entry["Event"] = event
	entry["UID"] = context.GetUID()
	entry["Tag"] = x.root.Tag
	entry["Label"] = context.GetLabel()
	entry["Msg"] = msg
	entry["Data"] = data
	entry["Time"] = x.timestamp()

	if context.IsHighlighted() {
		entry["Highlight"] = true
	}

	var bytes []byte
	var err error
	bytes, err = json.Marshal(entry)
	if err != nil {
		x.internalerror(WrapError(err, "Could not marshal log entry"))
		return
	}

	x.writer.Write(bytes)
	x.writer.Write([]byte("\n"))

}

// ComponentEvent logs an event generated by a Component.  It should
// only be called by a Root or an OutputDriver chaining outputs.
func (x *JSONOutput) ComponentEvent(component *Component,
	event ComponentEventClass,
	msg string,
	data *D) {

	if InvalidComponentEventClass(event) {
		x.internalerror(NewError("ComponentEventClass out of range",
			component.GetUID(), event))
		return
	}

	x.contextevent("component", component, ComponentEventClassText[event], msg, data)

	// end ComponentEvent
}

// TaskEvent logs an event generated by a Task.  It should only be
// called by a Root or an OutputDriver chaining outputs.
func (x *JSONOutput) TaskEvent(task *Task,
	event TaskEventClass) {

	var msg string = task.Activity

	switch event {
	case TASK_BEGIN:
		msg += " start"

	case TASK_END:
		if task.Timed {
			msg += " success"
		}

	case TASK_ERROR:
		msg += " failure"

	default:
		x.internalerror(NewError("TaskEventClass out of range for TaskEvent()",
			task.GetUID(), event))
		return

	}

	x.contextevent("task", task, TaskEventClassText[event], msg, task.Data)

	// end TaskEvent
}

// TaskProgress logs an event generated by a Task.  It should only be
// called by a Root or an OutputDriver chaining outputs.
func (x *JSONOutput) TaskProgress(task *Task,
	event TaskEventClass,
	msg string,
	data *D) {

	if InvalidTaskEventClass(event) {
		x.internalerror(NewError("TaskEventClass out of range for TaskProgress()",
			task.GetUID(), event))
		return
	}

	x.contextevent("task", task, TaskEventClassText[event], msg, data)

	// end TaskProgress
}
