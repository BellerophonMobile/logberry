package logberry

import (
	"time"
)

// Task represents a particular function or activity.  While a
// Component may persist for some time and do many different things, a
// Task is generally comparatively short lived and executes a
// particular instance of a chain of work.
//
// In general a Task is meant to be used within a single thread of
// execution, and the calling code is responsible for managing any
// concurrent manipulation.
type Task struct {
	uid    uint64
	parent Context
	root   *Root
	label  string

	activity string

	timed bool
	start time.Time

	data *D

	mute bool
	highlight bool
}

func newtask(parent Context, activity string, data []interface{}) *Task {

	t := &Task{
		uid:    newcontextuid(),
		parent: parent,
		root:   parent.GetRoot(),
		label:  parent.GetLabel(),

		activity: activity,

		data: DAggregate(data),
	}

	t.data.Set(t.root.FieldPrefix+"Parent", t.parent.GetUID())

	return t

}

// Component creates a new component context as a child of this task.
// Parameter label should be a usable short identifier for the new
// component, but its specific format and meaning is left up to the
// caller.  If the first field of the data is of type ComponentClass,
// the class of the new component will be set as such; the default is
// COMPONENT.  An instantiation log event will be generated by this
// call, including any data given.
//
// This is safe to call concurrently.
func (x *Task) Component(label string, data ...interface{}) *Component {
	return newcomponent(x, label, data...)
}

// Task creates a new task context as a child of this task.  Parameter
// activity should be a short natural language description of the work
// carried out by this activity, without any terminating punctuation.
// Any data given will be associated with the task and reported with
// its events.  This call does not produce a log event.  Use Begin()
// to indicate the start of a long running task.
//
// This is safe to call concurrently.
func (x *Task) Task(activity string, data ...interface{}) *Task {
	return newtask(x, activity, data)
}


// GetLabel returns the label for this Task, which is not the same as
// its activity given at instantiation.  The label is a tag for log
// events, taken at instantiation as the label of its parent.  Unless
// labels have been manually modified at some point, this will be the
// label of the closest ancestor Component.
func (x *Task) GetLabel() string {
	return x.label
}

// GetUID returns the unique identifier for this Task.
func (x *Task) GetUID() uint64 {
	return x.uid
}

// GetParent returns the Context containing this Task.
func (x *Task) GetParent() Context {
	return x.parent
}

// GetRoot returns the Root for this Task.
func (x *Task) GetRoot() *Root {
	return x.root
}

// GetActivity returns the work description for this Task.
func (x *Task) GetActivity() string {
	return x.activity
}

// GetTimed returns whether or not the Task is being timed.
func (x *Task) GetTimed() bool {
	return x.timed
}

// GetStart returns the timepoint at which this task began, indicated
// by calling Time().  Zero is returned if it is not being timed.
func (x *Task) GetStart() time.Time {
	return x.start
}


// Time indicates that this Task should be timed, starting now.  It
// does not generate a log event.
func (x *Task) Time() *Task {
	x.timed = true
	x.start = time.Now()
	return x
}

// Clock returns how long this Task has been running up to this point
// in time.  Zero is returned if the task in not being timed (Time()
// was not called).  No log event is generated by this, but the
// duration is added to the Task's data.  Any previously set duration
// is overridden.
func (x *Task) Clock() time.Duration {

	if !x.timed {
		return 0
	}

	d := time.Now().Sub(x.start)
	x.data.Set(x.root.FieldPrefix+"Duration", d)
	return d

}

// AddData incorporates the given key/value pair into the data
// associated and reported with this Task.  This call does not
// generate a log event.  The host Task is passed through as the
// return.  Among other things, this function is useful to silently
// accumulate data into the Task as it proceeds, to be reported when
// it concludes.
func (x *Task) AddData(k string, v interface{}) *Task {
	(*x.data)[k] = v
	return x
}

// AggregateData incorporates the given data into that associated and
// reported with this Task.  The rules for this construction are
// explained in D.AggregateFrom().  This call does not generate a log
// event.  The host Task is passed through as the return.  Among other
// things, this function is useful to silently accumulate data into
// the Task as it proceeds, to be reported when it concludes.
func (x *Task) AggregateData(data ...interface{}) *Task {
	x.data.AggregateFrom(data)
	return x
}


// Mute indicates that this Task should not generate log events.  This
// is useful when using the Task merely to organize subcomponents and
// tasks.  Specific OutputDrivers may ignore this.
func (x *Task) Mute() *Task {
	x.mute = true
	return x
}

// Unmute indicates that this Task should no longer be muted.
func (x *Task) Unmute() *Task {
	x.mute = false
	return x
}

// IsMute returns true iff the Task is muted.
func (x *Task) IsMute() bool {
	return x.mute
}

// Highlight indicates that the Task should be distinguished in some
// way in the output.  The specific behavior implementing this is
// determined by the OutputDrivers, which may ignore the flag.
func (x *Task) Highlight() *Task {
	x.highlight = true
	return x
}

// ClearHighlight indicates that the Task should no longer be
// distinguished in the log output.
func (x *Task) ClearHighlight() *Task {
	x.highlight = false
	return x
}

// IsHighlighted returns true iff the Task is highlighted.
func (x *Task) IsHighlighted() bool {
	return x.highlight
}


// Calculation is a data modifier that adds the given expression or
// result to the Task under the field "Calculation".
// 
// This call does not generate a log event.  The host Task is passed
// through as the return.
func (x *Task) Calculation(calculation interface{}) *Task {
	x.AddData("Calculation", calculation)
	return x
}

// File is a data modifier that adds the given filename or descriptor
// to the Task under the field "File".
// 
// This call does not generate a log event.  The host Task is passed
// through as the return.
func (x *Task) File(file interface{}) *Task {
	x.AddData("File", file)
	return x
}

// Resource is a data modifier that adds the given resource identifier
// or description to the Task under the field "Resource".
// 
// This call does not generate a log event.  The host Task is passed
// through as the return.
func (x *Task) Resource(resource interface{}) *Task {
	x.AddData("Resource", resource)
	return x
}

// Service is a data modifier that adds the given service identifier
// or description to the Task under the field "Service".
// 
// This call does not generate a log event.  The host Task is passed
// through as the return.
func (x *Task) Service(service interface{}) *Task {
	x.AddData("Service", service)
	return x
}

// User is a data modifier that adds the given name or description to
// the Task under the field "User".
// 
// This call does not generate a log event.  The host Task is passed
// through as the return.
func (x *Task) User(user interface{}) *Task {
	x.AddData("User", user)
	return x
}

// Endpoint is a data modifier that adds the given target identifier
// or description to the Task under the field "Endpoint".
// 
// This call does not generate a log event.  The host Task is passed
// through as the return.
func (x *Task) Endpoint(endpoint interface{}) *Task {
	x.AddData("Endpoint", endpoint)
	return x
}


// Success is a termination notifier, generating an end log event
// reporting that the Task has concluded successfully.  If the task is
// being timed it will be clocked and the duration reported.  The
// given data is accumulated into the task using D.AggregateFrom().
// It always returns nil.  Continuing to use the Task will not cause
// an error but is discouraged.
func (x *Task) Success(data ...interface{}) error {

	x.Clock()
	x.data.AggregateFrom(data)
	x.root.TaskEvent(x, TASK_END)

	return nil

}

// Error is a termination notifier, generating an error log event
// reporting that the Task has had an unrecoverable fault.  If the
// Task is being timed it will be clocked and the duration reported.
// The given data is accumulated into the task using
// D.AggregateFrom().  An error is returned wrapping the original
// error with a message reporting that the Task's activity has failed.
// Continuing to use the Task will not cause an error but is
// discouraged.
func (x *Task) Error(err error, data ...interface{}) error {

	// Note that this can't just throw err into the data blob because
	// the standard errors package error interface doesn't expose much,
	// even the message, so the marshalers don't get anything in that
	// common case.  Hence the reduction to a string via Error().

	x.Clock()
	x.data.AggregateFrom(data)
	x.data.Set(x.root.FieldPrefix+"Error", err.Error())

	x.root.TaskEvent(x, TASK_ERROR)

	return WrapError(err, x.activity+" failed")

}

// Failure is a termination notifier, generating an error log event
// reporting that the Task has had an unrecoverable fault.  If the
// Task is being timed it will be clocked and the duration reported.
// The given data is accumulated into the task using
// D.AggregateFrom().  An error is returned reporting that the Task's
// activity has failed with the given message.  Continuing to use the
// Task will not cause an error but is discouraged.
//
// Failure and Error are essentially the same, the difference being
// that Failure is useful to both report and generate a fault detected
// directly by the calling code, rather than one caused by an
// underlying error returned from another function or component.
func (x *Task) Failure(msg string, data ...interface{}) error {

	x.Clock()
	x.data.AggregateFrom(data)
	x.data.Set(x.root.FieldPrefix+"Error", msg)
	x.root.TaskEvent(x, TASK_ERROR)

	return WrapError(NewError(msg), x.activity+" failed")

}

// Begin generates a begin log event reporting that a task has
// started.  This is useful to report the start of a long-running
// activity.  The given data is accumulated into the task using
// D.AggregateFrom().  The host Task is passed through as the return.
func (x *Task) Begin(data ...interface{}) *Task {
	x.data.AggregateFrom(data)
	x.root.TaskEvent(x, TASK_BEGIN)
	return x
}

// Info generates an informational log event reporting the given
// message.  Unlike most of the Task functions, the given data is NOT
// accumulated into the Task.  This is useful for reporting
// intermediary, large, or other data that need not be reported with
// all of the Task's events.
func (x *Task) Info(msg string, data ...interface{}) {
	x.root.TaskProgress(x, TASK_INFO, msg, DAggregate(data))
}

// Warning generates a warning log event reporting that a fault was
// encountered but the Task is proceeding acceptably.  Unlike most of
// the Task functions, the given data is NOT accumulated into the
// Task.
//
func (x *Task) Warning(msg string, data ...interface{}) {
	x.root.TaskProgress(x, TASK_WARNING, msg, DAggregate(data))
}
